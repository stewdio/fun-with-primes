<!DOCTYPE html>
<html>
<body></body>
<script src="gpu-browser.2.6.4.min.js"></script>
<script>




//  100.

// const 
// searchRange = 100,
// expectedNumberOfPrimes = 25
// fastestCPU = undefined,
// fastestGPU = 0.011




//  1 thousand.

// const 
// searchRange = 1000,
// expectedNumberOfPrimes = 168,
// fastestCPU = undefined,
// fastestGPU = 0.013




//  10 thousand.

// const 
// searchRange = 1000 * 10,
// expectedNumberOfPrimes = 1229,
// fastestCPU = undefined,
// fastestGPU = 0.011




//  100 thousand.

// const 
// searchRange = 1000 * 100,
// expectedNumberOfPrimes = 9592,
// fastestCPU = undefined,
// fastestGPU = 0.013




//  1 million.

// const 
// searchRange = 1000 * 1000,
// expectedNumberOfPrimes = 78498,
// fastestCPU = 0.046,
// fastestGPU = 0.013




//  10 million.

const 
searchRange = 1000 * 1000 * 10,
expectedNumberOfPrimes = 664579,
fastestCPU = 0.862,
fastestGPU = 0.012




//  100 million.
//	THIS IS A BAAAAD RESULT!  :(
//	Only about 1/5th of the primes are found
//	perhaps due to integer overflow?!

// const 
// searchRange = 1000 * 1000 * 100,
// expectedNumberOfPrimes = 5761455,
// fastestCPU = 18.404,
// fastestGPU = Infinity




//  1 billion.
//  WARNING: THIS MAY CRASH YOUR MACHINE!!!!!!!!!!!
//  Uncaught Error: Texture size [22362,22360] generated by kernel 
//  is larger than supported size [16384,16384]

// const 
// searchRange = 1000 * 1000 * 1000,
// expectedNumberOfPrimes = 50847534,
// fastestCPU = 458.76,
// fastestGPU = Infinity








//  We’re going to use the GPU.js library
//  to do many small computations in parallel.
//  See https://github.com/gpujs/gpu.js/

const gpu = new GPU({ mode: 'webgl2' })
console.log( 'WebGL2 support:', GPU.isWebGL2Supported )


//  What’s the field of numbers we’d like to test?
//  This is SMALLER than the search range
//  because we can eliminate even numbers 
//  and the number 2 right from the start.

const 
searchFieldLength = Math.ceil( searchRange / 2 - 1.5 ),
createSearchField = gpu.createKernel( function(){

	if( this.thread.x === 0 ) return 2
	return 3 + 2 * ( this.thread.x - 1 )

})
.setPipeline( true )
.setOutput([ searchFieldLength ])
// .setStrictIntegers( true )
// .setOptimizeFloatMemory( true )




//  STRATEGY: 
//  Do everything in one single render loop.
//  This means duplicated effort in classifying primes / composites,
//  but at least it’s all running in parallel in theory...?

const primify = gpu.createKernel( function( searchField ){
	
	const n = searchField[ this.thread.x ]

	let isPrime = true
	for( let i = 0; i < this.thread.x; i ++ ){

		const p = searchField[ i ]


		//  If this number is evenly divisible by this prime
		//  then we can mark it as “composite”
		//  thereby removing it from our search.

		if( n % p === 0 ){ isPrime = false; break }


		//  If we’ve crossed the “halfway point”
		//  between zero and this number
		//  and it still hasn’t been marked as “prime”
		//  congratulations, we should do so now.
		//  The idea here is it’s faster to compute p * p
		//  and bail now, than to do more % operations.
			
		if( p * p > n ) break
	}
	if( isPrime ){ return n }
	else { return 0 }


})
.setPipeline( true )
.setOutput([ searchFieldLength ])
// .setStrictIntegers( true )//  Seems to have no effect on my particular case.
// .setOptimizeFloatMemory( true )//  This really seems to slow things down.
// .setTactic( 'speed' )//  Seems to have no effect on my particular case.
// .setFixIntegerDivisionAccuracy( true )
// .setTactic( 'precision' )








let
searchField,
computed, 
r = 0


console.log( 

	'\n\nWe are searching for prime numbers lower than', 
	searchRange.toLocaleString(),
	'\nwhich gives us a searchFieldLength of', 
	searchFieldLength.toLocaleString(), 
	'numbers.\n\n'
)
searchField = createSearchField()




//  On your marks...

console.log( '\nStarted at\n', new Date(), '\n\n' )
const startedAt = window.performance.now()


//  EXECUTE ! EXECUTER ! EXECUTEST !

computed = primify( searchField )


//  That’s it, we’re done! What’s the stats man??

const
endedAt = window.performance.now(),
totalDelta = endedAt - startedAt,
totalDeltaSeconds = totalDelta / 1000,
minutesDelta = Math.floor( totalDelta / 60000 ),
secondsDelta = totalDelta - ( minutesDelta * 60000 ),
secondsDeltaRounded = Math.round( secondsDelta ) / 1000

console.log( '\nEnded at\n', new Date(), '\n\n' )
console.log( '\nExecution time was', minutesDelta, 'minutes and', secondsDeltaRounded, 'seconds.\n\n' )

createSearchField.destroy()
primify.destroy()




//  Now this part, intepreting the results,
//  will take some extra time.
//  But this is merely compiling results.

console.log( 'computed', computed.toArray() )
const filtered = computed.toArray().reduce( function( filtered, n ){

	if( n > 0 ) filtered.push( n )
	return filtered

}, [])
console.log( 'filtered', filtered )


console.log( 

	'\n\nFound', ( filtered.length ).toLocaleString(), 'primes', 
	'under', ( searchRange ).toLocaleString(), '\n\n\n'
)




//  Did we achieve what we set out to do?

const resultIsCorrect = filtered.length === expectedNumberOfPrimes
console.log( 

	'\n\nThis result is', 
	( resultIsCorrect ? 'CORRECT!' : 'F’ING TERRIBLE.' ),
	'\n\n\n'
)
if( resultIsCorrect ){


	//  Let’s only compare the CPU and GPU records
	//  if we have non-zero data for the CPU record.

	if( fastestCPU > 0 ){

		if( totalDeltaSeconds < fastestCPU ){

			console.log( '\n\nGood: The GPU was faster, as it should be. CPU record was:', fastestCPU, 'seconds\n\n' )
		}
		else {

			console.log( '\n\nHuh. Seems the CPU record was faster:', fastestCPU, 'seconds.\n\n' )
		}
	}



	//  If this is a good result
	//  and we’ve got a speed record on our hands...

	if( totalDeltaSeconds < fastestGPU ){

		console.log( 

			'\n\n',
			 totalDeltaSeconds.toLocaleString(), 
			'seconds',
			'\n\n',
			'!!!  THIS IS A NEW GPU RECORD FOR ME  !!!',
			'\n\n\n'
		)
	}
	else {

		console.log( '\n\n(Sorry, this did not beat our previous GPU record of', fastestGPU, 'seconds.)\n\n\n' )
	}
}








</script>
</html>